#
# DO NOT MODIFY!!!!
# This file is automatically generated by racc 1.4.5
# from racc grammer file "juli_parser.y".
#

require 'racc/parser'


module Absyn
  class Node
    def accept(visitor)
      visitor.visit_node(self)
    end
  end
  
  class DefaultNode < Node
    attr_accessor :str
  
    def initialize(str)
      @str = str
    end
  
    def accept(visitor)
      visitor.visit_default(self)
    end
  end
  
  class ArrayNode < Node
    attr_accessor :array
  
    def initialize
      @array      = Array.new
    end
  
    def add(child)
      case child
      when String
        @array << DefaultNode.new(child)
      else
        @array << child
      end
      self
    end
  
    def accept(visitor)
      visitor.visit_array(self)
    end
  end
  
  class HeaderNode < Node
    attr_accessor :level, :name
  
    def initialize(level, name)
      @level  = level
      @name   = name
    end
  
    def accept(visitor)
      visitor.visit_header(self)
    end
  end
  
  class Visitor
    def visit_node(n); end
    def visit_array(n); end
    def visit_default(n); end
    def visit_header(n); end
  end
end


class JuliParser < Racc::Parser

module_eval <<'..end juli_parser.y modeval..idddf308a8c6', 'juli_parser.y', 91

# build Intermediate tree from Absyn tree.
#
#   h1
#   Orange
#   h2
#   Apple
#   h1
# â†“
#
#   h1
#   | +- Orange
#   | +- h2
#   |   +- Apple
#   h1
class TreeBuilder < Absyn::Visitor
  def initialize
    @curr_level = 999
    @root = @curr_node = Intermediate::HeaderNode.new(0, '(root)')
  end

  def root
    @root
  end

  def visit_array(n)
    # scan current level and gather DefaultNode into one
    str = ''
    for child in n.array do
      case child
      when Absyn::DefaultNode
        str += child.str
      else
        if str != ''
          @curr_node.add(Intermediate::DefaultNode.new(str))
          str = ''
        end
        build_subtree(child)
      end
    end
    if str != ''
      @curr_node.add(Intermediate::DefaultNode.new(str))
    end
  end

private
  def build_subtree(absyn_header)
    # When @curr_node points to upper (e.g. root) and parse level-1 as
    # follows, build new node under the upper and shift @curr_node to it:
    #
    #   (root)          - @curr_node
    #     test
    #     = NAME        - we are here!
    #     ...
    #
    if @curr_node.level < absyn_header.level
      new_node = Intermediate::HeaderNode.new(absyn_header)
      @curr_node.add(new_node)
      @curr_node = new_node

    # When @curr_node points to lower level (e.g. 'Option' below)
    # and parses 'SEE ALSO' (level=1) as follows, find parent, 
    # build new node under it, and shift @curr_node to the new node:
    #
    #   ...
    #   === Option      - @curr_node
    #   ...
    #   = SEE ALSO      - we are here!
    else
      new_node = Intermediate::HeaderNode.new(absyn_header)
      @curr_node.find_upper(absyn_header.level).add(new_node)
      @curr_node = new_node
    end
  end
end

  require 'erb'
  require 'juli/visitor'

  # parse one file, build Intermediate tree, then generate HTML
  def parse(in_file)
    File.open(in_file) do |io|
      @in_io = io
      yyparse self, :scan
    end
    tree = TreeBuilder.new
    @root.accept(tree)
    Visitor::Html.new.run(in_file, tree.root)
  end

private
  def scan
    while line = @in_io.gets do
      case line
      when /^\s*$/
        # skip empty line
      when /^=\s+(.*$)$/
        yield :H, 1; yield :STRING, $1
      when /^==\s+(.*$)$/
        yield :H, 2; yield :STRING, $1
      when /^===\s+(.*$)$/
        yield :H, 3; yield :STRING, $1
      when /^====\s+(.*$)$/
        yield :H, 4; yield :STRING, $1
      when /^=====\s+(.*$)$/
        yield :H, 5; yield :STRING, $1
      when /^======+\s+(.*$)$/
        yield :H, 6; yield :STRING, $1
      else
        yield :ANY, line
      end
    end
    yield false, nil
  end

..end juli_parser.y modeval..idddf308a8c6

##### racc 1.4.5 generates ###

racc_reduce_table = [
 0, 0, :racc_error,
 1, 6, :_reduce_1,
 0, 7, :_reduce_2,
 2, 7, :_reduce_3,
 2, 8, :_reduce_4,
 1, 8, :_reduce_none ]

racc_reduce_n = 6

racc_shift_n = 9

racc_action_table = [
     4,     7,     5,     3,     8 ]

racc_action_check = [
     2,     3,     2,     1,     4 ]

racc_action_pointer = [
   nil,     3,    -2,     1,     1,   nil,   nil,   nil,   nil ]

racc_action_default = [
    -2,    -6,    -1,    -6,    -6,    -5,    -3,     9,    -4 ]

racc_goto_table = [
     1,     2,     6 ]

racc_goto_check = [
     1,     2,     3 ]

racc_goto_pointer = [
   nil,     0,     1,     0 ]

racc_goto_default = [
   nil,   nil,   nil,   nil ]

racc_token_table = {
 false => 0,
 Object.new => 1,
 :H => 2,
 :STRING => 3,
 :ANY => 4 }

racc_use_result_var = false

racc_nt_base = 5

Racc_arg = [
 racc_action_table,
 racc_action_check,
 racc_action_default,
 racc_action_pointer,
 racc_goto_table,
 racc_goto_check,
 racc_goto_default,
 racc_goto_pointer,
 racc_nt_base,
 racc_reduce_table,
 racc_token_table,
 racc_shift_n,
 racc_reduce_n,
 racc_use_result_var ]

Racc_token_to_s_table = [
'$end',
'error',
'H',
'STRING',
'ANY',
'$start',
'text',
'elements',
'element']

Racc_debug_parser = false

##### racc system variables end #####

 # reduce 0 omitted

module_eval <<'.,.,', 'juli_parser.y', 15
  def _reduce_1( val, _values)
 @root = val[0]
  end
.,.,

module_eval <<'.,.,', 'juli_parser.y', 18
  def _reduce_2( val, _values)
 Absyn::ArrayNode.new
  end
.,.,

module_eval <<'.,.,', 'juli_parser.y', 19
  def _reduce_3( val, _values)
 val[0].add(val[1])
  end
.,.,

module_eval <<'.,.,', 'juli_parser.y', 22
  def _reduce_4( val, _values)
 Absyn::HeaderNode.new(val[0], val[1])
  end
.,.,

 # reduce 5 omitted

 def _reduce_none( val, _values)
  val[0]
 end

end   # class JuliParser
